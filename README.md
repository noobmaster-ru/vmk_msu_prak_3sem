task2:

    task2_1:
    Вычислить по методу Ньютона корень квадратный из числа x,
    находящимся во входном потоке (использовался цикл, в котором 
    считывался каждый элемент последовательности, который
    впоследствии обрабатывался методом Ньютона для вычисления корня
    квадратного)

    task2_2_1:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера (для данной задачи использовался
    аналогичный task2_1 алгоритм, только вычисления производились
    по схеме Горнера)

    task2_2_2:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера, а также посчитать производную 
    (аналогичное решение task2_2_1, только с производной)

    task2_2_3:
    По заданной последовательности чисел, вычислить многочлен
    n-ой степени по схеме Горнера, а также посчитать интеграл
    (использовался алгоритм  
        integral *= x;
        integral += b*x/(n+1);
        n -= 1;
    где b - i-й коэффициент посл-ти, 
    n - степень многочлена для i-й итерации, integral - итоговая сумма(интеграл), 
    x - точка)
	
    task2_3:
    Описать рекурсивную и итеративную версии функции i-го
    члена Фибоначчи (функция Fib1, зависящая от i-го эл-та посл-ти
    считает i-е число Фибоначчи итеративно, а функция Fib2, зависящая
    от итогового эл-та посл-ти, считает i-е число Фибоначчи рекурсивно)

    task2_4:
    Описать функцию, преобразующую вещественную константу, 
    заданную строкой, в тип double (осуществлена единственная функция
    str2double, на вход которой подается массив типа char, которая 
    преобразует строку в число)
	
	task2_5:
    Описать тип "список слов"; написать программу, которая
    вводит строку из непустых слов и строит список из этих слов;
    преобразовать список по следующему правилу: удалить все
    слова из списка, совподающие с последним
    (сначала создаём список, затем находим последний элемент в списке 
    и сравниваем каждый элемент с последним, удаляем сначала первые элементы,если они совпадут,
    затем все последующие)
    
	task2_6:
    Описать тип "дерево поиска" с неотрицательными целыми
    ключами; написать программу, которая вводит эл-ты 3-х
    видов:
    +<num>
    -<num>
    ?<num>
    Число с плюсом добавляется в список, если его еще нет
    Число с минусом удаляется из списка, если оно в нем есть
    Число со знаком вопроса ищет элемент и отвечает "yes"
    или "no"
    (tree append(tree t, elemtype n) - функция, добавляющая элемент n в дерево поиска t, если его нет;
    void in_order(tree t) - функция печаетает дерево LKP;
    tree minValueNode(tree t)- функция находит минимальный элемент в правом поддереве и возвращает ссылку на это звено;
    tree delete_elem(tree t, elemtype n) - функция, удаляющая из дерева t элемент n, если он там есть;
    int find(tree t, elemtype n) - функция, которая ищет элемент n в дереве t; 0 - есть в дереве,1 - нет в дереве;
    void delete_tree(tree t) - функция, удаляющая дерево t с освобождением памяти;)

    task2_7:
    К написанной "программе-калькулятор" добавить функции
    умножжения, вычитания и возведения в степень
    (void getlex() - выделяет из входного потока текущую лексему;
    void expr() - распознает выражение и вычисляет его значение;
    void add() - распознает слагаемое и вычисляет его значение;
    void mult() - распознает множитель и вычисляет его значение;
    void error() - сообщает об ошибке в выражении и передает управление в начало функции main(в точку begin))

    Для того, чтобы скомпилировать программы выше и запустить их, 
    достаточно написать следующие команды:
    gcc <program_name> -o <program_name>
    ./<program_name>
	
task3:

    Описать программу, которая, пока не получен конец файла, выполняет 
    в цикле следующие действия:
        1) cчитывает из stdin очередную строку,
        2) преобразует ее в последовательность (список) слов,
        3) выводит в stdout полученную последовательность слов в исходном порядке,
        4) выводит слова последовательности в лексикографическом порядке.
    При выводе в первой строке напечатать длину списка, в каждой последующей – очередной элемент списка.
    Задача была решена путем разбития на 2 подпрограммы: functions.c(в 
    которой описаны все функции, требующиеся для решения задачи) и
    main.c(обрабатывающая stdin)

    functions.c состоит из следующих функций:
        - void clearlist() - удаляет все звенья списка с освобождением памяти
        - void null_list() - задает начальные установки для списка
        - void termlist() - добавляет в список последний "NULL" элемент
        - void nullbuf() - очищает буфер и задает начальные установки
        - void addsym() - добавляет очередной символ в буфер
        - void addword() - добавляет слово из буфера в список
        - void printlist() - печатает список
        - int symset(int c) - определяет специальный символ
        - void sortinglist() - сортирует список в лексикографическом порядке
    
    Для того, чтобы скомпилировать программу и запустить ее была
    использована утилита make, для этого был создан файл Makefile,
    расположенный в директории с программой, следующие команды
    компилируют и запускают прoграмму соответственно:
    make all или просто make
	./a.out
task4:

    Нужно реализовать несколько команд Unix. Команды, обязательные для реализации:
    1. echo – печатает свои аргументы через пробел, возможны флаги (см. man echo). 
    2. pwd – напечатать имя текущего каталога.
    3. ls – вывести список файлов текущего каталога.(Возможны флаги:
    -R – вывести имена всех файлов текущего каталога, а также файлов, содержащихся во вложенных подкаталогах,
    -l – показать атрибуты: тип, права доступа, имя владельца, размер,
    -g – показать имя группы владельца.)
    Далее необходимо реализовать одну команду из группы по выбору, мои команды:
    1. mv old_file new_file 
        (аргументы могут быть каталогами)
    2. grep substring filename
        Результат: строки файла filename, содержащие substring как подстроку (возможен флаг - v; 
        в этом случае результат – это строки, которые не содержат substring как подстроку).
    3. cat filenames
        Возможен флаг:
        -n – с нумерацией строк (если файлов несколько, то нумерация сквозная)
    Каждая команды реализована в отдельном файле, названном в честь самой команды.
    Чтобы скомпилировать программу можно воспользоваться Makefile и запусить make {команда}, 
    далее в командной строке ввести ./{команда} {необходимые аргументы для команды}
task 6:
    
    «Обедающие философы»
    Пять философов гуляют по саду и размышляют, время от времени заходя в беседку (столовую) подкрепиться 
        — там круглый стол с пятью стульями и блюдом спагетти в центре стола. 
    Спагетти длинные и скользкие — чтобы их кушать, нужны две вилки. 
    На столе всего пять вилок. Места философов фиксированы: i-й философ садится на i-й стул. 
    Когда философ садится за стол, он должен взять левую вилку, если она свободна 
    (иначе ждать пока сосед слева поест и положит вилку), взять правую вилку (если она занята, подождать), 
        затем покушать с помощью двух вилок, положить левую и правую вилки и пойти в сад продолжить размышления.
     Исключить возможность тупиковой ситуации, когда все философы сели за стол и взяли левую вилку.
    
    Чтобы скомпилировать программу можно воспользоваться Makefile и запусить: make  далее make run или ./philosophers
